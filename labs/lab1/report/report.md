---
## Front matter
title: "Лабораторная работа №1"
subtitle: "Работа с git"
author: "Аскеров Александр Эдуардович"

## Generic otions
lang: ru-RU
toc-title: "Содержание"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc: true # Table of contents
toc-depth: 2
lof: true # List of figures
lot: false # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: IBM Plex Serif
romanfont: IBM Plex Serif
sansfont: IBM Plex Sans
monofont: IBM Plex Mono
mathfont: STIX Two Math
mainfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
romanfontoptions: Ligatures=Common,Ligatures=TeX,Scale=0.94
sansfontoptions: Ligatures=Common,Ligatures=TeX,Scale=MatchLowercase,Scale=0.94
monofontoptions: Scale=MatchLowercase,Scale=0.94,FakeStretch=0.9
mathfontoptions:
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric
## Pandoc-crossref LaTeX customization
figureTitle: "Рис."
tableTitle: "Таблица"
listingTitle: "Листинг"
lofTitle: "Список иллюстраций"
lotTitle: "Список таблиц"
lolTitle: "Листинги"
## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Приобрести практические навыки работы с системой управления версиями Git.

# Задание

Изучить работу Git.

# Теоретическое введение

Git – распределённая система управления версиями. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года.

# Выполнение лабораторной работы

## Подготовка

### Установка имени и электронной почты

В случае если ранее git не использовался, для начала нам необходимо осуществить установку. Выполним следующие команды, чтобы git узнал наше имя и электронную почту.

![Установка имени и электронной почты](image/1.png){#fig:001 width=70%}

### Параметры установки окончаний строк

Укажем параметры установки окончаний строк со значениями true и input.

![Параметры установки окончаний строк](image/2.png){#fig:002 width=70%}

### Установка отображения unicode

Установим соответствующий флаг, чтобы избежать нечитаемых строк.

![Избежание нечитаемых строк](image/3.png){#fig:003 width=70%}

## Создание проекта

### Создадим страницу «Hello World»

Начнём работу в пустом рабочем каталоге с создания пустого каталога с именем hello, затем войдём в него и создадим там файл с именем hello.html.

![Страница с Hello World](image/4.png){#fig:004 width=70%}

### Создание репозитория

Чтобы создать git репозиторий из этого каталога, выполним команду git init.

![Создание нового репозитория](image/5.png){#fig:005 width=70%}

### Добавление файла в репозиторий

Добавим файл в репозиторий.

![Добавление файла в репозиторий](image/6.png){#fig:006 width=70%}

### Проверка состояния репозитория

Проверим текущее состояние репозитория.

![Текущее состояние репозитория](image/7.png){#fig:007 width=70%}

Видим, что коммитить нечего – в репозитории хранится текущее состояние рабочего каталога, и нет никаких изменений, ожидающих записи.

## Внесение изменений

### Изменим страницу «Hello World»

Добавим кое-какие HTML-теги к нашему приветствию. Изменим содержимое файла hello.html на следующее.

![Содержимое hello.html](image/8.png){#fig:008 width=70%}

Проверим состояние рабочего каталога.

![Состояние рабочего каталога](image/9.png){#fig:009 width=70%}

Видно, что git знает, что файл hello.html был изменён, но при этом эти изменения ещё не зафиксированы в репозитории.

## Индексация изменений

Теперь выполним команду git, чтобы проиндексировать изменения. Проверим состояние.

![Индексация изменений](image/10.png){#fig:010 width=70%}

Изменения файла hello.html были проиндексированы. Это означает, что git теперь знает об изменении, но изменение пока не записано в репозиторий. Следующий коммит будет включать в себя проиндексированные изменения.

### Коммит изменений

Сделаем коммит и проверим состояние.

![Коммит](image/11.png){#fig:011 width=70%}

Откроется редактор.

В первой строке введём комментарий: «Added h1 tag». Сохраним файл и выйдем из редактора.

![Комментарий](image/12.png){#fig:012 width=70%}

Теперь ещё раз проверим состояние.

![Проверка состояния](image/13.png){#fig:013 width=70%}

Рабочий каталог чистый, можно продолжить работу.

### Добавим стандартные теги страницы

Изменим страницу «Hello World», чтобы она содержала стандартные теги html и body.

![Содержимое hello.html](image/14.png){#fig:014 width=70%}

Теперь добавим это изменение в индекс git.

![Добавление изменения в индекс git](image/15.png){#fig:015 width=70%}

Теперь добавим заголовки HTML (секцию head) к странице «Hello World».

![Содержимое hello.html](image/16.png){#fig:016 width=70%}

Проверим текущий статус.

![Текущий статус](image/17.png){#fig:017 width=70%}

Обратим внимание на то, что hello.html указан дважды в состоянии. Первое изменение (добавление стандартных тегов) проиндексировано и готово к коммиту. Второе изменение (добавление заголовков HTML) является непроиндексированным. Если бы мы делали коммит сейчас, заголовки не были бы сохранены в репозиторий.

Произведём коммит проиндексированного изменения (значение по умолчанию), а затем ещё раз проверим состояние.

![Коммит и проверка состояния](image/18.png){#fig:018 width=70%}

Состояние команды говорит о том, что hello.html имеет незафиксированные изменения, но уже не в буферной зоне.

Теперь добавим второе изменение в индекс, а затем проверим состояние с помощью команды git status.

![Добавление второго изменения в индекс и проверка состояния](image/19.png){#fig:019 width=70%}

Второе изменение проиндексировано и готово к коммиту.

Сделаем коммит второго изменения.

![Коммит](image/20.png){#fig:020 width=70%}

### История

Получим список произведённых изменений.

![Список произведённых изменений](image/21.png){#fig:021 width=70%}

### Получение старых версий

Команда checkout позволяет вернуться назад в истории – она копирует любой снимок из репозитория в рабочий каталог.

Получим хэши предыдущих версий.

![Хэши предыдущих версий](image/22.png){#fig:022 width=70%}

Изучим данные лога и найдём хэш для первого коммита. Он должен быть в последней строке данных. Используем этот хэш-код (достаточно первых 7 знаков) в команде ниже. 
Затем проверим содержимое файла hello.html.

![Содержимое hello.html при первом коммите](image/23.png){#fig:023 width=70%}

Вернёмся к последней версии в ветке master.

![Возврат к последней версии в ветке master](image/24.png){#fig:024 width=70%}

master – имя ветки по умолчанию. Переключая имена веток, мы попадаем на последнюю версию выбранной ветки.

### Создание тегов версий

Назовём текущую версию страницы hello первой (v1).

Создадим тег первой версии.

![Тег первой версии](image/25.png){#fig:025 width=70%}

Теперь текущая версия страницы называется v1.

После этого создадим тег для версии, которая идёт перед текущей версией и назовем её v1-beta. В первую очередь нам надо переключиться на предыдущую версию.

![Переключение на предыдущую версию](image/26.png){#fig:026 width=70%}

Это версия c тегами html и body, но ещё пока без head. Давайте сделаем её версией v1-beta.

![Тег версии v1-beta](image/27.png){#fig:027 width=70%}

### Переключение по имени тега

Теперь попробуем попереключаться между двумя отмеченными версиями.

![Переключение между двумя отмеченными версиями](image/28.png){#fig:028 width=70%}

### Просмотр тегов с помощью команды tag

Мы можем увидеть, какие теги доступны, используя команду git tag.

![Доступные теги](image/29.png){#fig:029 width=70%}

Мы также можем посмотреть теги в логе.

![Просмотр тегов через лог](image/30.png){#fig:030 width=70%}

## Отмена локальных изменений (до индексации)

### Переключимся на ветку master

Убедимся, что мы находимся на последнем коммите ветки master, прежде чем продолжить работу.

![Переход на ветку master](image/31.png){#fig:031 width=70%}

### Изменим hello.html

Иногда случается, что мы изменили файл в рабочем каталоге, и хотим отменить последние коммиты. С этим справится команда git checkout.

Внесём изменение в файл hello.html в виде нежелательного комментария.

![Добавление комментария в hello.html](image/32.png){#fig:032 width=70%}

### Проверим состояние

Сначала проверим состояние рабочего каталога.

![Состояние рабочего каталога](image/33.png){#fig:033 width=70%}

Мы видим, что файл hello.html был изменен, но еще не проиндексирован.

### Отмена изменений в рабочем каталоге

Используем команду git checkout для переключения версии файла hello.html в репозитории.

![Переключение версии](image/34.png){#fig:034 width=70%}

Команда git status показывает нам, что не было произведено никаких изменений, не зафиксированных в рабочем каталоге.

## Отмена проиндексированных изменений (перед коммитом)

### Изменим файл и проиндексируем изменения

Внесём изменение в файл hello.html в виде нежелательного комментария.

![Добавление комментария в hello.html](image/35.png){#fig:035 width=70%}

Проиндексируем это изменение.

![Индексация изменения](image/36.png){#fig:036 width=70%}

### Проверим состояние

Проверим состояние нежелательного изменения.

![Проверка состояния](image/37.png){#fig:037 width=70%}

Состояние показывает, что изменение было проиндексировано и готово к коммиту.

### Выполним сброс буферной зоны

К счастью, вывод состояния показывает нам именно то, что мы должны сделать для отмены индексации изменения.

![Сброс буферной зоны к HEAD](image/38.png){#fig:038 width=70%}

Команда git reset сбрасывает буферную зону к HEAD. Это очищает буферную зону от изменений, которые мы только что проиндексировали.

### Переключимся на версию коммита

![Переключение на версию коммита](image/39.png){#fig:039 width=70%}

Наш рабочий каталог опять чист.

## Отмена коммитов

### Отмена коммитов

Иногда мы понимаем, что новые коммиты являются неверными, и хотим их отменить. Есть несколько способов решения этого вопроса, здесь мы будем использовать самый безопасный. Мы отменим коммит путём создания нового коммита, отменяющего нежелательные изменения.

### Изменим файл и сделаем коммит

Изменим файл hello.html на следующий.

![Отредактированный hello.html](image/40.png){#fig:040 width=70%}

Выполним следующие команды.

![Коммит](image/41.png){#fig:041 width=70%}

### Сделаем коммит с новыми изменениями, отменяющими предыдущие

Чтобы отменить коммит, нам необходимо сделать коммит, который удаляет изменения, сохранённые нежелательным коммитом.

![Возврат](image/42.png){#fig:042 width=70%}

Перейдём в редактор, где мы можем отредактировать коммит-сообщение по умолчанию или оставить все как есть. Сохраним и закроем файл.

![Редактирование комментария](image/43.png){#fig:043 width=70%}

### Проверим лог

Проверка лога показывает нежелательные и отменённые коммиты в наш репозиторий.

![Журнал](image/44.png){#fig:044 width=70%}

## Удаление коммитов из ветки

git revert является мощной командой, которая позволяет отменить любые коммиты в репозиторий. Однако, и оригинальный и «отменённый» коммиты видны в истории ветки (при использовании команды git log).

Часто мы делаем коммит, и сразу понимаем, что это была ошибка. Было бы неплохо иметь команду «возврата», которая позволила бы нам сделать вид, что неправильного коммита никогда и не было. Команда «возврата» даже предотвратила бы появление нежелательного коммита в истории git log.

### Команда git reset

При получении ссылки на коммит (т.е. хэш, ветка или имя тега), команда git reset:

- перепишет текущую ветку, чтобы она указывала на нужный коммит;
- опционально сбросит буферную зону для соответствия с указанным коммитом;
- опционально сбросит рабочий каталог для соответствия с указанным коммитом.

### Проверим нашу историю

Давайте сделаем быструю проверку нашей истории коммитов. Выполним следующее.

![Журнал](image/45.png){#fig:045 width=70%}

Мы видим, что два последних коммита в этой ветке – «Oops» и «Revert Oops». Удалим их с помощью сброса.

### Для начала отметим эту ветку

Но прежде чем удалить коммиты, отметим последний коммит тегом, чтобы потом можно было его найти.

![Тег для коммита](image/46.png){#fig:046 width=70%}

### Сброс коммитов к предшествующим коммиту Oops

Глядя на историю лога, мы видим, что коммит с тегом «v1» является коммитом, предшествующим ошибочному коммиту. Сбросим ветку до этой точки. Поскольку ветка имеет тег, мы можем использовать имя тега в команде сброса (если она не имеет тега, мы можем использовать хэш-значение).

![Сброс ветки](image/47.png){#fig:047 width=70%}

Наша ветка master теперь указывает на коммит v1, а коммитов Oops и Revert Oops в ветке уже нет. Параметр --hard указывает, что рабочий каталог должен быть обновлен в соответствии с новым head ветки.

### Ничего никогда не теряется

Что же случается с ошибочными коммитами? Оказывается, что коммиты всё ещё находятся в репозитории. На самом деле, мы всё ещё можем на них ссылаться. Например, в начале этого урока мы создали для отменённого коммита тег «oops». Посмотрим на все коммиты.

![Все коммиты](image/48.png){#fig:048 width=70%}

Мы видим, что ошибочные коммиты не исчезли. Они всё ещё находятся в репозитории. Просто они отсутствуют в ветке master. Если бы мы не отметили их тегами, они по-прежнему находились бы в репозитории, но не было бы никакой возможности ссылаться на них, кроме как при помощи их хэш-имён. Коммиты, на которые нет ссылок, остаются в репозитории до тех пор, пока не будет запущен сборщик мусора.

### Опасность сброса

Сброс в локальных ветках, как правило, безопасен. Последствия любой «аварии» как правило, можно восстановить простым сбросом с помощью нужного коммита. Однако, если ветка «расшарена» на удалённых репозиториях, сброс может сбить с толку других пользователей ветки.

## Удаление тега oops

### Удаление тега oops

Тег oops свою функцию выполнил. Давайте удалим его и коммиты, на которые он ссылался, сборщиком мусора.

![Удаление тега](image/49.png){#fig:049 width=70%}

Тег «oops» больше не будет отображаться в репозитории.

## Внесение изменений в коммиты

### Изменим страницу, а затем сделаем коммит

Добавим в страницу комментарий автора.

![Комментарий](image/50.png){#fig:050 width=70%}

Выполним следующее.

![Коммит](image/51.png){#fig:051 width=70%}

### Необходим email

После совершения коммита к комментарию стоит добавить электронную почту автора. 

Обновим страницу hello, включив в неё email.

![Редактирование hello.html](image/52.png){#fig:052 width=70%}

### Изменим предыдущий коммит

Мы не хотим создавать отдельный коммит только ради электронной почты. Поэтому изменим предыдущий коммит, включив в него адрес электронной почты.

![Изменение комментария](image/53.png){#fig:053 width=70%}

### Просмотр истории

Выполним следующее.

![Журнал](image/54.png){#fig:054 width=70%}

Мы можем увидеть, что оригинальный коммит «автор» заменён коммитом «автор/email». Этого же эффекта можно достичь путём сброса последнего коммита в ветке, и повторного коммита новых изменений.

## Перемещение файлов

### Переместим файл hello.html в каталог lib

Сейчас мы собираемся создать структуру нашего репозитория. Перенесём страницу в каталог lib.

![Перенос страницы в каталог lib](image/55.png){#fig:055 width=70%}

## Второй способ перемещения файлов

Мы могли бы выполнить:

``` bash
mkdir lib
mv hello.html lib
git add lib/hello.html
git rm hello.html
```

### Коммит в новый каталог

Сделаем коммит этого перемещения.

![Коммит](image/56.png){#fig:056 width=70%}

## Подробнее о структуре

### Добавление index.html

Добавим файл index.html в наш репозиторий.

![Файл index.html](image/57.png){#fig:057 width=70%}

Укажем в нём следующее содержимое.

![Содержимое index.html](image/58.png){#fig:058 width=70%}

Добавим файл и сделаем коммит.

![Добавление файла и коммит](image/59.png){#fig:059 width=70%}

Теперь при открытии index.html, мы увидим кусок страницы hello в маленьком окошке.

![Результат работы файла index.html](image/60.png){#fig:060 width=70%}

## Git внутри: Каталог .git

### Каталог .git

Выполним следующее.

![Вся информация о git](image/61.png){#fig:061 width=70%}

Это каталог, в котором хранится вся информация git.

### База данных объектов

Выполним следующее.

![База данных объектов](image/62.png){#fig:062 width=70%}

Мы видим набор каталогов, имена которых состоят из 2 символов. Имена каталогов являются первыми двумя буквами хэша sha1 объекта, хранящегося в git.

### Углубляемся в базу данных объектов

Выполним следующее.

![Просмотр одного из каталогов из objects](image/63.png){#fig:063 width=70%}

Здесь мы смотрим в один из каталогов с именем из 2 букв. В результате мы видим файлы с именами из 38 символов. Это файлы, содержащие объекты, хранящиеся в git. Они сжаты и закодированы, поэтому просмотр их содержимого может мало чем помочь.

### Config File

Выполним следующее.

![Содержимое файла конфигурации](image/64.png){#fig:064 width=70%}

Это файл конфигурации, создающийся для каждого конкретного проекта. Записи в этом файле будут перезаписывать записи в файле .gitconfig нашего главного каталога, по крайней мере в рамках этого проекта.

### Ветки и теги

Выполним следующее.

![Содержимое тега v1](image/65.png){#fig:065 width=70%}

Здесь каждый файл соответствует тегу, ранее созданному с помощью команды git tag. Его содержание – это всего лишь хэш коммита, привязанный к тегу.

Каталог heads практически аналогичен, но используется для веток, а не тегов. На данный момент у нас есть только одна ветка, так что всё, что мы увидим в этом каталоге – это ветка master.

### Файл HEAD

Выполним следующее.

![Содержимое файла HEAD](image/66.png){#fig:066 width=70%}

Файл HEAD содержит ссылку на текущую ветку, в данный момент это должна быть ветка master.

## Работа непосредственно с объектами git

### Поиск последнего коммита

Выполним следующее.

![Последний коммит в репозитории](image/67.png){#fig:067 width=70%}

Эта команда показывает последний коммит в репозиторий. SHA1 хэш у разных пользователей, вероятно, отличается от этого, но отображаемый результат похож на этот.

### Вывод последнего коммита с помощью SHA1 хэша

Выполним следующее.

![Вывод последнего коммита с помощью SHA1 хэша](image/68.png){#fig:068 width=70%}

### Поиск дерева

Мы можем вывести дерево каталогов, ссылка на который идёт в коммите. Это должно быть описание файлов (верхнего уровня) в нашем проекте (для конкретного коммита). Используем SHA1 хэш из строки «дерева», из списка выше.

Выполним следующее.

![Дерево каталогов](image/69.png){#fig:069 width=70%}

### Вывод каталога lib

Выполним следующее.

![Вывод каталога lib](image/70.png){#fig:070 width=70%}

### Вывод файла hello.html

Выполним следующее.

![Вывод файла hello.html](image/71.png){#fig:071 width=70%}

### Исследуйте самостоятельно

Исследуем git репозиторий вручную самостоятельно. Посмотрим, удастся ли нам найти оригинальный файл hello.html с самого первого коммита вручную по ссылкам SHA1 хэша в последнем коммите.

## Создание ветки

Пора сделать наш hello world более выразительным. Так как это может занять некоторое время, лучше переместить эти изменения в отдельную ветку, чтобы изолировать их от изменений в ветке master.

### Создадим ветку

Назовём нашу новую ветку «style».

Выполним следующее.

![Переключение на новую ветку style](image/72.png){#fig:072 width=70%}

Команда git status сообщает о том, что мы находимся в ветке «style».

### Добавим файл стилей style.css

Выполним следующее.

![Новый CSS-файл](image/73.png){#fig:073 width=70%}

Укажем в нём следующее содержимое.

![Стиль для заголовка](image/74.png){#fig:074 width=70%}

Выполним следующее.

![Добавление файла в репозиторий и коммит](image/75.png){#fig:075 width=70%}

### Изменим основную страницу

Обновим файл hello.html, чтобы использовать стили style.css.

![Редактирование файла hello.html](image/76.png){#fig:076 width=70%}

Выполним следующее.

![Обновление файла в репозитории и коммит](image/77.png){#fig:077 width=70%}

### Изменим index.html

Обновим файл index.html, чтобы он тоже использовал style.css.

![Редактирование файла index.html](image/78.png){#fig:078 width=70%}

Выполним следующее.

![Обновление файла в репозитории и коммит](image/79.png){#fig:079 width=70%}

## Навигация по веткам

Теперь в нашем проекте есть две ветки.

Выполним следующее.

![Журнал](image/80.png){#fig:080 width=70%}

### Переключение на ветку master

Используем команду git checkout для переключения между ветками.

![Переключение ветки](image/81.png){#fig:081 width=70%}

Сейчас мы находимся на ветке master. Это заметно по тому, что файл hello.html не использует стили style.css.

### Вернёмся к ветке style

Выполним следующее.

![Переключение ветки](image/82.png){#fig:082 width=70%}

Содержимое lib/hello.html подтверждает, что мы вернулись на ветку style.

## Изменения в ветке master

Пока мы меняли ветку style, кто-то решил обновить ветку master. Они добавили файл README.md.

### Создадим файл README в ветке master

Выполним следующее.

![Переключение ветки](image/83.png){#fig:083 width=70%}

Создадим файл README.md.

![Новый файл README.md](image/84.png){#fig:084 width=70%}

## Сделаем коммит изменений README.md в ветку master

Выполним следующее.

![Добавление файла в репозиторий и коммит](image/85.png){#fig:085 width=70%}

### Просмотр отличающихся веток

### Просмотрим текущие ветки

Теперь у нас в репозитории есть две отличающиеся ветки. Используем следующую лог-команду для просмотра веток и их отличий.

![Просмотр веток и их отличий](image/86.png){#fig:086 width=70%}

## Слияние

### Слияние веток

Слияние переносит изменения из двух веток в одну. Вернёмся к ветке style и сольём master со style.

![Слияние веток](image/87.png){#fig:087 width=70%}

![Дерево коммитов](image/88.png){#fig:088 width=70%}

## Создание конфликта

### Вернёмся в master и создадим конфликт

Вернёмся в ветку master.

![Переключение ветки](image/89.png){#fig:089 width=70%}

Внесём следующие изменения.

![Редактирование файла hello.html](image/90.png){#fig:090 width=70%}

Выполним следующее.

![Обновление файла в репозитории и коммит](image/91.png){#fig:091 width=70%}

### Просмотр веток

Выполним следующее.

![Дерево коммитов](image/92.png){#fig:092 width=70%}

После коммита «Added README» ветка master была объединена с веткой style, но в настоящее время в master есть дополнительный коммит, который не был слит со style.

Последнее изменение в master конфликтует с некоторыми изменениями в style. На следующем шаге мы решим этот конфликт.

## Разрешение конфликтов

### Слияние master с веткой style

Теперь вернёмся к ветке style и попытаемся объединить её с новой веткой master.

Выполним следующее.

![Конфликт при слиянии веток](image/93.png){#fig:093 width=70%}

Если мы откроем lib/hello.html, то увидим следующее.

![Содержимое hello.html](image/94.png){#fig:094 width=70%}

Первый раздел – версия текущей ветки (style). Второй раздел – версия ветки master.

### Решение конфликта

Нам необходимо вручную разрешить конфликт. Внесём изменения в lib/hello.html для достижения следующего результата.

![Содержимое hello.html](image/95.png){#fig:095 width=70%}

### Сделаем коммит решения конфликта

Выполним следующее.

![Обновление файла в репозитории и коммит](image/96.png){#fig:096 width=70%}

### 1.22.4 Перебазирование как альтернатива слиянию

Рассмотрим различия между слиянием и перебазированием. Для того, чтобы это сделать, нам нужно вернуться в репозиторий в момент до первого слияния, а затем повторить те же действия, но с использованием перебазирования вместо слияния.

Мы будем использовать команду reset для возврата веток к предыдущему состоянию.

## Сброс ветки style

### Сброс ветки style

Вернёмся на ветке style к точке перед тем, как мы слили её с веткой master. Мы можем сбросить ветку к любому коммиту. По сути, это изменение указателя ветки на любую точку дерева коммитов.

В этом случае мы хотим вернуться в ветке style в точку перед слиянием с master. Нам необходимо найти последний коммит перед слиянием.

Выполним следующее.

![Переключение на ветку style](image/97.png){#fig:097 width=70%}

![Дерево коммитов](image/98.png){#fig:098 width=70%}

Мы видим, что коммит «Updated index.html» был последним на ветке style перед слиянием. Сбросим ветку style к этому коммиту.

![Перемещение к другому коммиту](image/99.png){#fig:099 width=70%}

### Проверим ветку

Поищем лог ветки style. У нас в истории больше нет коммитов слияний.

![Дерево коммитов](image/100.png){#fig:100 width=70%}

## Сброс ветки master

### Сброс ветки master

Добавив интерактивный режим в ветку master, мы внесли изменения, конфликтующие с изменениями в ветке style. Вернёмся в ветке master в точку перед внесением конфликтующих изменений. Это позволяет нам продемонстрировать работу команды git rebase, не беспокоясь о конфликтах.

![Переключение на ветку master](image/101.png){#fig:101 width=70%}

![Дерево коммитов](image/102.png){#fig:102 width=70%}

Коммит «Added README» идёт непосредственно перед коммитом конфликтующего интерактивного режима. Мы сбросим ветку master к коммиту «Added README».

![Перемещение к другому коммиту](image/103.png){#fig:103 width=70%}

![Дерево коммитов](image/104.png){#fig:104 width=70%}

Лог выглядит, как будто репозиторий был перемотан назад во времени к точке до какого-либо слияния.

## Перебазирование

Используем команду rebase вместо команды merge. Мы вернулись в точку до первого слияния и хотим перенести изменения из ветки master в нашу ветку style. На этот раз для переноса изменений из ветки master мы используем команду git rebase вместо слияния.

![Перебазирование](image/105.png){#fig:105 width=70%}

![Журнал](image/106.png){#fig:106 width=70%}

### Слияние VS перебазирование

Конечный результат перебазирования очень похож на результат слияния. Ветка style в настоящее время содержит все свои изменения, а также все изменения ветки master. Однако, дерево коммитов значительно отличается. Дерево коммитов ветки style было переписано таким образом, что ветка master является частью истории коммитов. Это делает цепь коммитов линейной и гораздо более читабельной.

## Слияние в ветку master

Мы поддерживали соответствие ветки style с веткой master (с помощью rebase), теперь же сольём изменения style в ветку master.

### Слияние style в master

Выполним следующее.

![Слияние веток](image/107.png){#fig:107 width=70%}

Поскольку последний коммит ветки master прямо предшествует последнему коммиту ветки style, git может выполнить ускоренное слияние-перемотку. При быстрой перемотке вперёд git просто передвигает указатель вперёд, таким образом указывая на тот же коммит, что и ветка style.

При быстрой перемотке конфликтов быть не может.

### Просмотрим логи

Выполним следующее.

![Журнал](image/108.png){#fig:108 width=70%}

Теперь ветки style и master идентичны.

## Клонирование репозиториев

### Перейдём в рабочий каталог

Перейдём в рабочий каталог и сделаем клон нашего репозитория hello.

![Переход в рабочий каталог](image/109.png){#fig:109 width=70%}

Сейчас мы находимся в рабочем каталоге. Здесь есть единственный репозиторий под названием «hello».

### Создадим клон репозитория hello

Создадим клон репозитория.

![Клон репозитория](image/110.png){#fig:110 width=70%}

В нашем рабочем каталоге теперь есть два репозитория: оригинальный репозиторий «hello» и клонированный репозиторий «cloned_hello».

## Просмотр клонированного репозитория

### Взглянем на клонированный репозиторий

![Содержимое клонированного репозитория](image/111.png){#fig:111 width=70%}

Мы видим список всех файлов на верхнем уровне оригинального репозитория README.md, index.html и lib.

### Просмотрим историю репозитория

Выполним следующее.

![Журнал](image/112.png){#fig:112 width=70%}

Мы видим список всех коммитов в новый репозиторий, и он (более или менее) совпадает с историей коммитов в оригинальном репозитории. Единственная разница должна быть в названиях веток.

### Удалённые ветки

Мы видим ветку master (HEAD) в списке истории. Мы также видим ветки со странными именами (origin/master, origin/style и origin/HEAD).

## Что такое origin?

Выполним следующее.

![Удалённый репозиторий](image/113.png){#fig:113 width=70%}

Мы видим, что клонированный репозиторий знает об имени по умолчанию удалённого репозитория. Посмотрим, можем ли мы получить более подробную информацию об имени по умолчанию.

Выполним следующее.

![Подробная информация об удалённом репозитории](image/114.png){#fig:114 width=70%}

## Удалённые ветки

Давайте посмотрим на ветки, доступные в нашем клонированном репозитории.

![Ветки в репозитории](image/115.png){#fig:115 width=70%}

Как мы видим, в списке только ветка master. Где ветка style? Команда git branch выводит только список локальных веток по умолчанию.

### Список удалённых веток

Для того, чтобы увидеть все ветки, попробуем следующую команду.

![Просмотр всех веток](image/116.png){#fig:116 width=70%}

Git выводит все коммиты в оригинальный репозиторий, но ветки в удалённом репозитории не рассматриваются как локальные. Если мы хотим собственную ветку style, мы должны сами её создать. Скоро мы увидим, как это делается.

## Изменение оригинального репозитория

Внесём некоторые изменения в оригинальный репозиторий, чтобы затем попытаться извлечь и слить изменения из удалённой ветки в текущую.

### Внесём изменения в оригинальный репозиторий hello

Выполним следующее.

![Перемещение](image/117.png){#fig:117 width=70%}

Примечание: Сейчас мы находимся в репозитории hello

Внесём следующие изменения в файл README.md.

![Редактируем README](image/118.png){#fig:118 width=70%}

Выполним следующее.

![Обновление файла в репозитории и коммит](image/119.png){#fig:119 width=70%}

Теперь в оригинальном репозитории есть более поздние изменения, которых нет в клонированной версии. Далее мы извлечём и сольём эти изменения в клонированный репозиторий.

### Извлечение изменений

Научимся извлекать изменения из удалённого репозитория.

![Перекачиваем файлы](image/120.png){#fig:120 width=70%}

![Журнал](image/121.png){#fig:121 width=70%}

Сейчас мы находимся в репозитории cloned_hello.

На данный момент в репозитории есть все коммиты из оригинального репозитория, но они не интегрированы в локальные ветки клонированного репозитория.

В истории выше найдём коммит «Changed README in original repo». Обратим внимание, что коммит включает в себя коммиты «origin/master» и «origin/HEAD».

Теперь посмотрим на коммит «Updated index.html». Мы увидим, что локальная ветка master указывает на этот коммит, а не на новый коммит, который мы только что извлекли.

Выводом является то, что команда git fetch будет извлекать новые коммиты из удалённого репозитория, но не будет сливать их с нашими наработками в локальных ветках.

### Проверим README.md

Мы можем продемонстрировать, что клонированный файл README.md не изменился.

![Содержимое README](image/122.png){#fig:122 width=70%}

## Слияние извлечённых изменений

### Сольём извлечённые изменения в локальную ветку master

Выполним следующее.

![Слияние веток](image/123.png){#fig:123 width=70%}

### Ещё раз проверим файл README.md

Сейчас мы увидим изменения.

![Версия README-файла](image/124.png){#fig:124 width=70%}

Хотя команда git fetch не сливает изменения, мы можем вручную слить изменения из удалённого репозитория.

Теперь давайте рассмотрим объединение fetch и merge в одну команду.

![git pull](image/125.png){#fig:125 width=70%}

## Добавление ветки наблюдения

Ветки, которые начинаются с remotes/origin являются ветками оригинального репозитория. Обратим внимание, что у нас больше нет ветки под названием style, но система контроля версий знает, что в оригинальном репозитории ветка style была.

### Добавим локальную ветку, которая отслеживает удалённую ветку

Выполним следующее.

![Отслеживание удалённой ветки](image/126.png){#fig:126 width=70%}

Теперь мы можем видеть ветку style в списке веток и логе.

## Чистые репозитории

Чистые репозитории (без рабочих каталогов) обычно используются для расшаривания. Обычный git-репозиторий подразумевает, что мы будем использовать его как рабочую директорию, поэтому вместе с файлами проекта в актуальной версии, git хранит все служебные, «чисто-репозиториевские» файлы в поддиректории .git. В удалённых репозиториях нет смысла хранить рабочие файлы на диске (как это делается в рабочих копиях), а все что им действительно нужно – это дельты изменений и другие бинарные данные репозитория. Вот это и есть «чистый репозиторий».

## Создадим чистый репозиторий

![Чистый репозиторий](image/127.png){#fig:127 width=70%}

Сейчас мы находимся в рабочем каталоге.

Как правило, репозитории, оканчивающиеся на .git являются чистыми репозиториями. Мы видим, что в репозитории hello.git нет рабочего каталога. По сути, это есть не что иное, как каталог .git нечистого репозитория.

## Добавление удалённого репозитория

Давайте добавим репозиторий hello.git к нашему оригинальному репозиторию.

![Добавление репозитория hello.git](image/128.png){#fig:128 width=70%}

## Отправка изменений

Так как чистые репозитории, как правило, расшариваются на каком-нибудь сетевом сервере, нам необходимо отправить наши изменения в другие репозитории. Начнём с создания изменения для отправки.

Отредактируем файл README.md и сделаем коммит.

![Редактирование README.md](image/129.png){#fig:129 width=70%}

![Коммит](image/130.png){#fig:130 width=70%}

Теперь отправим изменения в общий репозиторий.

![Отправление изменений в общий репозиторий](image/131.png){#fig:131 width=70%}

Общим называется репозиторий, получающий отправленные нами изменения.

## Извлечение общих изменений

Научимся извлекать изменения из общего репозитория. Быстро переключимся в клонированный репозиторий и извлечём изменения, только что отправленные в общий репозиторий.

![Перемещение](image/132.png){#fig:132 width=70%}

![Извлечение общих изменений](image/133.png){#fig:133 width=70%}

# Выводы

Получены навыки работы с системой git.

# Список литературы{.unnumbered}

1. Git [Электронный ресурс]. URL: https://ru.wikipedia.org/wiki/Git.

